CREATE TABLE department(
	id_department serial PRIMARY KEY,
	name varchar NOT NULL,
	CONSTRAINT empty_name CHECK (trim(name) <> '')
);

CREATE TABLE post (
	id_post serial PRIMARY KEY,
	name varchar NOT NULL,
	salary real NOT NULL,
	CONSTRAINT empty_name CHECK (trim(name) <> ''),
	CONSTRAINT negative_salary CHECK (salary > 0)
);

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

--Заглушка для employee
CREATE OR REPLACE FUNCTION get_current_department() 
RETURNS int AS $$
BEGIN
    RETURN (3);
END;
$$ LANGUAGE plpgsql;

CREATE TABLE employee (
	id_employee uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
	surname varchar(50) NOT NULL,
	name varchar(50) NOT NULL,
	patronymic varchar(50) NOT NULL,
	address varchar NOT NULL,
	birthday date NOT NULL,
	id_post int NOT NULL REFERENCES post,
	id_department int NOT NULL REFERENCES department DEFAULT get_current_department(),
	CONSTRAINT empty_surname CHECK (trim(surname) <> ''),
	CONSTRAINT empty_name CHECK (trim(name) <> ''),
	CONSTRAINT empty_patronymic CHECK (trim(patronymic) <> ''),
	CONSTRAINT empty_address CHECK (trim(patronymic) <> ''),
	CONSTRAINT wrong_birthday CHECK (now() - birthday >= interval '18 years')
);

CREATE TABLE employee_role(
	id_role serial PRIMARY KEY,
	name varchar NOT NULl UNIQUE,
	CONSTRAINT empty_role CHECK (trim(name) <> '')
);

CREATE TABLE employee_account(
	id_employee uuid NOT NULL UNIQUE REFERENCES employee,
	login varchar(60) NOT NULL,
	password varchar NOT NULL,
	roles int[] NOT NULL,
	online bool NOT NULL DEFAULT false,
	CONSTRAINT empty_login CHECK (trim(login) <> '')
);

CREATE OR REPLACE FUNCTION get_current_employee() 
RETURNS uuid AS $$
BEGIN
    RETURN (SELECT id_employee
			FROM employee_account
			WHERE login = current_user);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION get_current_department() 
RETURNS int AS $$
BEGIN
    RETURN (WITH id_emp AS (
				SELECT id_employee ie
				FROM employee_account
				WHERE login = current_user)
			SELECT id_department
			FROM employee e
			JOIN id_emp ON id_emp.ie = e.id_employee);
END;
$$ LANGUAGE plpgsql;

CREATE TABLE employee_fired(
	id_employee uuid NOT NULL UNIQUE REFERENCES employee,
	reason text NOT NULL,
	date_fired date NOT NULL DEFAULT now()::date,
	CONSTRAINT empty_reason CHECK (trim(reason) <> ''),
	CONSTRAINT wrong_date_fired CHECK (date_fired = now()::date)
);

CREATE TABLE order_assign (
	id_order int PRIMARY KEY,
	id_employee uuid NOT NULL REFERENCES employee,
	id_old_post int NOT NULL REFERENCES post (id_post),
	id_new_post int NOT NULL REFERENCES post (id_post),
	reason text NOT NULL,
	date_assign date NOT NULL DEFAULT now(),
	CONSTRAINT empty_reason CHECK (trim(reason) <> ''),
	CONSTRAINT wrong_date_assign CHECK (date_assign = now()::date)
);

CREATE TABLE medicine_packaging_form (
	packaging_form varchar PRIMARY KEY
);

CREATE TABLE medicine (
	id_medicine serial PRIMARY KEY,
	name varchar NOT NULL,
	MNN varchar NOT NULL,
	pharm_group varchar NOT NULL,
	condition_release text NOT NULL,
	CONSTRAINT empty_name CHECK (trim(name) <> ''),
	CONSTRAINT empty_MNN CHECK (trim(MNN) <> ''),
	CONSTRAINT empty_pharm_group CHECK (trim(pharm_group) <> ''),
	CONSTRAINT empty_condition_release CHECK (trim(condition_release) <> '')
);

CREATE TABLE medicine_cost (
	id_medicine int NOT NULL REFERENCES medicine,
	packaging_form varchar NOT NULL REFERENCES medicine_packaging_form,
	cost real NOT NULL,
	CONSTRAINT negative_cost CHECK (cost > 0),
	CONSTRAINT medicine_cost_not_unique UNIQUE (id_medicine, packaging_form)
);

CREATE TABLE medicine_way_enter (
	way_enter varchar PRIMARY KEY
);

CREATE TABLE medicine_producer (
	producer varchar PRIMARY KEY
);

CREATE TABLE medicine_type_form (
	type_form varchar PRIMARY KEY
);

CREATE TABLE medicine_form (
	form varchar PRIMARY KEY,
	type_form varchar NOT NULL REFERENCES medicine_type_form
);

CREATE TABLE measure_measurability (
	measure varchar PRIMARY KEY
);

CREATE TABLE medicine_product (
	id_medicine_product uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
	id_medicine int NOT NULL REFERENCES medicine,
	name varchar NOT NULL,
	serial_number varchar NOT NULL UNIQUE,
	form varchar NOT NULL REFERENCES medicine_form,
	amount real NOT NULL,
	components jsonb NOT NULL,
	way_enter varchar NOT NULL REFERENCES medicine_way_enter,
	dosage_mode text NOT NULL,
	packaging_form varchar NOT NULL REFERENCES medicine_packaging_form,
	producer varchar NOT NULL REFERENCES medicine_producer,
	date_release date NOT NULL,
	storage_condition text NOT NULL,
	date_expiration date NOT NULL,
	analogues uuid[],
	decommissioned bool NOT NULL DEFAULT false,
	CONSTRAINT empty_name CHECK (trim(name) <> ''),
	CONSTRAINT empty_serial_number CHECK (trim(serial_number) <> ''),
	CONSTRAINT empty_dosage_mode CHECK (trim(dosage_mode) <> ''),
	CONSTRAINT empty_storage_condition CHECK (trim(storage_condition) <> ''),
	CONSTRAINT wrong_date_release CHECK (date_release <= now()),
	CONSTRAINT wrong_date_expiration CHECK (date_release < date_expiration),
	CONSTRAINT negative_amount CHECK (amount > 0)
);

CREATE TABLE medicine_product_decommissioned (
	id_medicine_product uuid NOT NULL UNIQUE REFERENCES medicine_product,
	reason varchar NOT NULL,
	amount real NOT NULL,
	measure varchar NOT NULL REFERENCES measure_measurability,
	date_decommission timestamp NOT NULL DEFAULT now(),
	CONSTRAINT empty_reason CHECK (trim(reason) <> ''),
	CONSTRAINT negative_amount CHECK (amount > 0)
);

CREATE TABLE storage_pharmacy (
	id_storage serial PRIMARY KEY,
	name varchar NOT NULL UNIQUE,
	CONSTRAINT empty_name CHECK (trim(name) <> '')
);

CREATE TABLE storage_place (
	id_place serial PRIMARY KEY,
	name varchar NOT NULL UNIQUE,
	CONSTRAINT empty_name CHECK (trim(name) <> '')
);

CREATE TABLE storage_medicine_product (
	id_department int NOT NULL REFERENCES department DEFAULT get_current_department(),
	id_storage int NOT NULL REFERENCES storage_pharmacy,
	id_place int NOT NULL REFERENCES storage_place,
	id_medicine_product uuid NOT NULL REFERENCES medicine_product,
	amount real NOT NULL,
	measure varchar NOT NULL REFERENCES measure_measurability DEFAULT 'шт.',
	CONSTRAINT storage_pkey PRIMARY KEY (id_department, id_storage, id_place, id_medicine_product),
	CONSTRAINT negative_amount CHECK (amount >= 0)
);

CREATE TABLE history_sale (
	id_sale uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
	id_department int NOT NULL REFERENCES department DEFAULT get_current_department(),
	date_sale timestamp NOT NULL DEFAULT now(),
	id_employee uuid NOT NULL REFERENCES employee DEFAULT get_current_employee()
);

CREATE TABLE history_sale_medicine_product (
	id_sale uuid NOT NULL REFERENCES history_sale,
	id_storage int NOT NULL REFERENCES storage_pharmacy,
	id_place int NOT NULL REFERENCES storage_place,
	id_medicine_product uuid NOT NULL REFERENCES medicine_product,
	amount real NOT NULL,
	measure varchar NOT NULL REFERENCES measure_measurability,
	cost real NOT NULL,
	CONSTRAINT negative_amount CHECK (amount > 0),
	CONSTRAINT negative_cost CHECK (cost > 0)
);

CREATE TABLE supplier (
	id_supplier serial PRIMARY KEY,
	name varchar NOT NULL UNIQUE,
	CONSTRAINT empty_name CHECK (trim(name) <> '')
);

CREATE TABLE waybill (
	id_waybill int PRIMARY KEY,
	date_waybill date NOT NULL,
	id_supplier int NOT NULL REFERENCES supplier,
	id_employee uuid NOT NULL REFERENCES employee DEFAULT get_current_employee(),
	id_department int NOT NULL REFERENCES department DEFAULT get_current_department(),
	CONSTRAINT wrong_date_waybill CHECK (date_waybill <= now())
);

CREATE TABLE waybill_medicine_product (
	id_waybill int NOT NULL REFERENCES waybill,
	id_medicine_product uuid NOT NULL REFERENCES medicine_product,
	amount real NOT NULL,
	measure varchar NOT NULL REFERENCES measure_measurability,
	cost real NOT NULL,
	CONSTRAINT negative_amount CHECK (amount > 0),
	CONSTRAINT negative_cost CHECK (cost > 0)
);

-------------------------------
-------------------------------
----Заполнение справочников----
-------------------------------
-------------------------------

INSERT INTO public.department(name)
	VALUES ('Рецептурно-процедурный'),
	('Готовых ЛС'),
	('Безрецептурного отпуска'),
	('Бесплатного льготного отпуска'),
	('Запасов');

INSERT INTO public.post(name, salary)
	VALUES ('Заведующий', 60000),
	('Заместитель заведующего', 50000),
	('Провизор-технолог', 45000),
	('Провизор-аналитик', 45000),
	('Фармацевт', 40000);

INSERT INTO public.employee_role(name)
	VALUES ('Сотрудник'),
	('Кассир'),
	('Управляющий отдела'),
	('Директор');

INSERT INTO public.medicine_packaging_form(packaging_form)
	VALUES ('Ампула'),
	('Пробирка'),
	('Туба'),
	('Тюбик-капельница'),
	('Стрип'),
	('Блистер'),
	('Флакон');

INSERT INTO public.medicine_way_enter(way_enter)
	VALUES ('Пероральный'),
	('Сублингвальный'),
	('Ректальный'),
	('Инъекционный'),
	('Ингаляционный'),
	('Трансдермальный'),
	('Интраназальный'),
	('Конъюнктивальный');

INSERT INTO public.medicine_type_form(type_form)
	VALUES ('Твёрдые'),
	('Жидкие'),
	('Мягкие'),
	('Газообразные');
	
INSERT INTO public.medicine_form(form, type_form)
	VALUES ('Таблетки', 'Твёрдые'),
	('Капсулы', 'Твёрдые'),
	('Порошки', 'Твёрдые'),
	('Драже', 'Твёрдые'),
	('Пастилки', 'Твёрдые'),
	('Гранулы', 'Твёрдые'),
	('Лиофилизаты', 'Твёрдые'),
	('Имплантаты', 'Твёрдые'),
	('Карандаши', 'Твёрдые'),
	('Тампоны', 'Твёрдые'),
	('Сборы', 'Твёрдые'),
	('Пленки', 'Твёрдые'),
	('Растворы', 'Жидкие'),
	('Капли', 'Жидкие'),
	('Сиропы', 'Жидкие'),
	('Суспензии', 'Жидкие'),
	('Эмульсии', 'Жидкие'),
	('Жидкие экстракты', 'Жидкие'),
	('Настойки', 'Жидкие'),
	('Эликсиры', 'Жидкие'),
	('Концентраты', 'Жидкие'),
	('Шампуни', 'Жидкие'),
	('Настои', 'Жидкие'),
	('Отвары', 'Жидкие'),
	('Мази', 'Мягкие'),
	('Кремы', 'Мягкие'),
	('Гели', 'Мягкие'),
	('Линименты', 'Мягкие'),
	('Пасты', 'Мягкие'),
	('Суппозитории', 'Мягкие'),
	('Пластыри', 'Мягкие'),
	('Жевательные резинки', 'Мягкие'),
	('Газы медицинские', 'Газообразные'),
	('Аэрозоли', 'Газообразные'),
	('Спреи', 'Газообразные'),
	('Ингаляционные', 'Газообразные');

INSERT INTO public.measure_measurability(measure)
	VALUES ('шт.'),
	('ящ.'),
	('мл.'),
	('г.'),
	('мг.'),
	('мкг.'),
	('кап.');

INSERT INTO public.medicine (name, MNN, pharm_group, condition_release)
VALUES ('Нурофен', 'Ибупрофен', 'Нестероидные противовоспалительные средства', 'Без рецепта'),
('Амоксиклав', 'Амоксициллин', 'Антибиотики пенициллинового ряда', 'По рецепту'),
('Эналаприл', 'Эналаприл', 'Ингибиторы АПФ', 'По рецепту'),
('Лозап', 'Лозартан', 'Блокаторы рецепторов ангиотензина II', 'По рецепту'),
('Супрастин', 'Хлоропирамин', 'Антигистаминные препараты', 'Без рецепта'),
('Мезим Форте', 'Панкреатин', 'Ферментные препараты', 'Без рецепта'),
('Афобазол', 'Фабомотизол', 'Анксиолитики', 'Без рецепта'),
('Кагоцел', 'Кагоцел', 'Противовирусные средства', 'Без рецепта'),
('Ксарелто', 'Ривароксабан', 'Антикоагулянты', 'По рецепту'),
('Мирамистин', 'Мирамистин', 'Антисептики', 'Без рецепта'),
-- Аналоги Нурофена (Ибупрофен)
('Ибупрофен-Тева', 'Ибупрофен', 'Нестероидные противовоспалительные средства', 'Без рецепта'),
('Фаспик', 'Ибупрофен', 'Нестероидные противовоспалительные средства', 'Без рецепта'),
('Миг 400', 'Ибупрофен', 'Нестероидные противовоспалительные средства', 'Без рецепта'),
-- Аналоги Амоксиклава
('Аугментин', 'Амоксициллин', 'Антибиотики пенициллинового ряда', 'По рецепту'),
('Панклав', 'Амоксициллин', 'Антибиотики пенициллинового ряда', 'По рецепту'),
-- Аналоги Эналаприла
('Энап', 'Эналаприл', 'Ингибиторы АПФ', 'По рецепту'),
('Берлиприл', 'Эналаприл', 'Ингибиторы АПФ', 'По рецепту'),
-- Новые лекарства с аналогами
('Парацетамол', 'Парацетамол', 'Анальгетики-антипиретики', 'Без рецепта'),
('Панадол', 'Парацетамол', 'Анальгетики-антипиретики', 'Без рецепта'),
('Цитрамон', 'Парацетамол', 'Анальгетики-антипиретики', 'Без рецепта'),
('Лоперамид', 'Лоперамид', 'Противодиарейные средства', 'Без рецепта'),
('Имодиум', 'Лоперамид', 'Противодиарейные средства', 'Без рецепта'),
('Омепразол', 'Омепразол', 'Ингибиторы протонной помпы', 'Без рецепта'),
('Ультоп', 'Омепразол', 'Ингибиторы протонной помпы', 'Без рецепта'),
('Омез', 'Омепразол', 'Ингибиторы протонной помпы', 'Без рецепта');





-------------------------------
-------------------------------
------Триггеры и функции-------
-------------------------------
-------------------------------

CREATE OR REPLACE FUNCTION set_medicine_product_analogues()
RETURNS TRIGGER AS $$
DECLARE
    analogue_ids uuid[];
BEGIN
    -- Проверяем, изменились ли критические поля
    IF TG_OP = 'UPDATE'
       AND OLD.form = NEW.form AND 
       OLD.way_enter = NEW.way_enter
       AND (OLD.components->0->>'Вещество') = (NEW.components->0->>'Вещество') 
	   THEN RETURN NEW; -- Если ключевые поля не изменились, выходим
    END IF;

    -- Находим ID всех аналогов (лекарств с совпадающими характеристиками)
    SELECT array_agg(DISTINCT mp.id_medicine_product) INTO analogue_ids
    FROM medicine_product mp
    WHERE mp.id_medicine_product != NEW.id_medicine_product
      AND mp.form = NEW.form
      AND mp.way_enter = NEW.way_enter
      AND (mp.components->0->>'Вещество') = (NEW.components->0->>'Вещество');
    
    -- Устанавливаем найденные аналоги для нового препарата
    NEW.analogues := analogue_ids;
    
    -- Добавляем ID нового препарата в analogues всех найденных аналогов
    IF analogue_ids IS NOT NULL THEN
        UPDATE medicine_product
        SET analogues = array_append(analogues, NEW.id_medicine_product)
        WHERE id_medicine_product = ANY(analogue_ids);
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Создаем триггер
CREATE TRIGGER trigger_set_analogues
BEFORE INSERT OR UPDATE ON medicine_product
FOR EACH ROW
EXECUTE FUNCTION set_medicine_product_analogues();



CREATE OR REPLACE FUNCTION get_medicine_products_analogues(_id_medicine_product uuid)
RETURNS TABLE (LIKE medicine_product) AS $$
BEGIN
    RETURN QUERY (SELECT *
		FROM medicine_product mp
		WHERE _id_medicine_product = ANY(analogues));
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE PROCEDURE delete_medicine_product(_id_medicine_product uuid)
LANGUAGE plpgsql
AS $BODY$
BEGIN
	UPDATE medicine_product
	SET analogues = array_remove(analogues, _id_medicine_product)
	WHERE _id_medicine_product = ANY(analogues);
	
	DELETE FROM medicine_product
	WHERE id_medicine_product = _id_medicine_product;
END;
$BODY$;



CREATE OR REPLACE FUNCTION set_medicine_product_names()
RETURNS TRIGGER AS $$
BEGIN
    -- Проверяем, изменились ли критические поля
    IF TG_OP = 'UPDATE' 
       AND OLD.form = NEW.form 
       AND (OLD.components->0->>'Мера') = (NEW.components->0->>'Мера') 
	   THEN RETURN NEW; -- Если ключевые поля не изменились, выходим
    END IF;

    WITH medicine_product_info AS (
		SELECT m.name
		FROM medicine m
		WHERE NEW.id_medicine = m.id_medicine
	)
	SELECT CONCAT(mpi.name || ' ' || (NEW.components->0->>'Мера') || ' ' || NEW.form)
	INTO NEW.name
	FROM medicine_product_info mpi;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Создаем триггер
CREATE TRIGGER trigger_set_names
BEFORE INSERT OR UPDATE ON medicine_product
FOR EACH ROW
EXECUTE FUNCTION set_medicine_product_names();



CREATE OR REPLACE PROCEDURE decommission_medicine_product(_id_medicine_product uuid, _reason varchar)
LANGUAGE SQL
AS $BODY$
	UPDATE medicine_product
	SET decommissioned = true
	WHERE id_medicine_product = _id_medicine_product;
	
	WITH am AS (
		SELECT amount
		FROM storage_medicine_product smp
		WHERE smp.id_medicine_product = _id_medicine_product
	)
    INSERT INTO public.medicine_product_decommissioned(id_medicine_product, reason, amount, measure)
		VALUES (_id_medicine_product, _reason, (SELECT * FROM am), 'шт.');

	UPDATE storage_medicine_product 
	SET amount = 0
	WHERE id_medicine_product = _id_medicine_product;
$BODY$;

CREATE OR REPLACE PROCEDURE employee_assign_order(_id_order int, _id_employee uuid, _new_post int, _reason text)
LANGUAGE SQL
AS $BODY$
	WITH old_post AS (
		SELECT id_post AS id_old_post
		FROM employee smp
		WHERE id_employee = _id_employee
	)
    INSERT INTO public.order_assign(id_order, id_employee, id_old_post, id_new_post, reason)
		VALUES (_id_order, _id_employee, (SELECT * FROM old_post), _new_post, _reason);

	UPDATE employee
	SET id_post = _new_post
	WHERE id_employee = _id_employee;
$BODY$;

CREATE OR REPLACE PROCEDURE clear_employee_data()
LANGUAGE plpgsql
AS $BODY$
DECLARE
	id_emp uuid;
BEGIN
	id_emp := (SELECT id_employee
				FROM employee_fired
				WHERE date_fired <= (now() - interval '5 year')::date)
	
	DELETE FROM order_assign
	WHERE id_employee = id_emp;

	DELETE FROM employee_fired
	WHERE id_employee = id_emp;
	
	DELETE FROM employee
	WHERE id_employee = id_emp;
END;
$BODY$;

CREATE OR REPLACE PROCEDURE clear_medicine_product_sales()
LANGUAGE plpgsql
AS $BODY$
DECLARE
	_id_sale uuid;
BEGIN
	_id_sale := (SELECT hs.id_sale as id
				FROM history_sale hs
				WHERE date_sale <= (now() - interval '1 year')::date)

	DELETE FROM history_sale_medicine_product hsmp
	WHERE hsmp.id_sale = _id_sale;

	DELETE FROM history_sale hs
	WHERE hs.id_sale = _id_sale;
END;
$BODY$;



CREATE OR REPLACE FUNCTION check_expired_medicine_product(_days interval)
RETURNS TABLE(id_medicine_product uuid) AS $$
BEGIN
    RETURN QUERY (SELECT mp.id_medicine_product
			FROM medicine_product mp
			WHERE date_expiration <= now()::date + _days
			AND decommissioned = false);
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION check_critical_amount_medicine_product(_critical_amount real)
RETURNS TABLE(LIKE storage_medicine_product) AS $$
BEGIN
    RETURN QUERY (SELECT *
			FROM storage_medicine_product smp
			WHERE amount <= _critical_amount);
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION check_password(_password varchar(60))
RETURNS void AS
$BODY$
BEGIN
	IF (trim(_password) = '')
	THEN
		RAISE EXCEPTION 'Пароль не может быть пустым!';
	END IF;

	IF (trim(_password) <> _password)
	THEN
		RAISE EXCEPTION 'Пароль должен быть без пробелов!';
	END IF;

	IF (length(_password) < 8)
	THEN
		RAISE EXCEPTION 'Пароль должен иметь больше 8 знаков!';
	END IF;

	IF (lower(_password) = _password OR _password !~ '[0-9]')
	THEN
		RAISE EXCEPTION 'Пароль должен иметь прописные и заглавные буквы, а также цифры!';
	END IF;

	IF ((SELECT COUNT(*) AS letter_count
		FROM ( SELECT regexp_split_to_table(_password, '') AS letter) AS letters
		GROUP BY letter
		ORDER BY letter
		LIMIT 1) >= length(_password)/2)
	THEN
		RAISE EXCEPTION 'Пароль не должен иметь больше половины одинаковых символов!';
	END IF;
END
$BODY$
LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION check_roles(_roles int[]) 
RETURNS void AS $$
DECLARE
    invalid_roles int[];
BEGIN
    invalid_roles := array(
        SELECT r 
        FROM unnest(_roles) AS r
        WHERE r NOT IN (SELECT id_role FROM employee_role)
    );
    
    IF array_length(invalid_roles, 1) > 0 THEN
        RAISE EXCEPTION 'Роли не существует: %', array_to_string(invalid_roles, ', ');
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE OR REPLACE FUNCTION create_employee_account()
RETURNS TRIGGER AS $$
DECLARE
	role int;
BEGIN
    PERFORM check_roles(NEW.roles);
    PERFORM check_password(NEW.password);
	
    NEW.password := crypt(NEW.password, gen_salt('bf'));
	NEW.login := CONCAT('apteka_u_', NEW.login);
	
	EXECUTE format(
            'CREATE USER %I WITH PASSWORD %L',
            NEW.login, NEW.password
        );
		
	FOREACH role IN ARRAY NEW.roles LOOP
        CASE
			WHEN role = 1 THEN 
				EXECUTE format('GRANT apteka_g_employee TO %I', NEW.login);
			WHEN role = 2 THEN
				EXECUTE format('GRANT apteka_g_cashier TO %I', NEW.login);
			WHEN role = 3 THEN
				EXECUTE format('GRANT apteka_g_department_manager TO %I', NEW.login);
			WHEN role = 4 THEN
				EXECUTE format('GRANT apteka_g_director TO %I', NEW.login);
		END CASE;
    END LOOP;
	
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Создаем триггер
CREATE TRIGGER trigger_create_account
BEFORE INSERT ON employee_account
FOR EACH ROW
EXECUTE FUNCTION create_employee_account();

CREATE OR REPLACE FUNCTION control_privileges(_roles int[], _id_employee uuid)
RETURNS void AS $$
DECLARE
	role int;
	login_employee varchar;
	role_employee int[];
	role_revoked int[];
	role_granted int[];
BEGIN
    PERFORM check_roles(_roles);

	-- Получаем роли сотрудника, явно преобразуя в массив
    SELECT roles, login INTO role_employee, login_employee
    FROM employee_account
    WHERE id_employee = _id_employee;

    -- Находим роли для добавления (есть в _roles, но нет у сотрудника)
    SELECT array_agg(DISTINCT r) INTO role_granted
    FROM unnest(_roles) r
    WHERE NOT (r = ANY(COALESCE(role_employee, '{}'::int[])));

    -- Находим роли для удаления (есть у сотрудника, но нет в _roles)
    SELECT array_agg(re) INTO role_revoked
    FROM unnest(COALESCE(role_employee, '{}'::int[])) re
    WHERE NOT (re = ANY(_roles));
    
	UPDATE employee_account 
        SET roles = (SELECT array_agg(DISTINCT elem)
        			FROM (SELECT unnest(array_cat(role_employee, role_granted)) AS elem
            				EXCEPT SELECT unnest(role_revoked))
					)
        WHERE id_employee = _id_employee
	RETURNING roles INTO role_employee;

	IF role_granted IS NOT NULL THEN
		FOREACH role IN ARRAY role_granted LOOP
    	    	CASE
			WHEN role = 1 THEN 
				EXECUTE format('GRANT apteka_g_employee TO %I', login_employee);
			WHEN role = 2 THEN
				EXECUTE format('GRANT apteka_g_cashier TO %I', login_employee);
			WHEN role = 3 THEN
				EXECUTE format('GRANT apteka_g_department_manager TO %I', login_employee);
			WHEN role = 4 THEN
				EXECUTE format('GRANT apteka_g_director TO %I', login_employee);
		END CASE;
    	END LOOP;
	END IF;

	IF role_revoked IS NOT NULL THEN
		FOREACH role IN ARRAY role_revoked LOOP
    	    	CASE
			WHEN role = 1 THEN 
				EXECUTE format('REVOKE apteka_g_employee FROM %I', login_employee);
			WHEN role = 2 THEN
				EXECUTE format('REVOKE apteka_g_cashier FROM %I', login_employee);
			WHEN role = 3 THEN
				EXECUTE format('REVOKE apteka_g_department_manager FROM %I', login_employee);
			WHEN role = 4 THEN
				EXECUTE format('REVOKE apteka_g_director FROM %I', login_employee);
		END CASE;
    	END LOOP;
	END IF;
	
	RAISE NOTICE 'Пользователю % Роли выданы: %, отобраны: %, сейчас: %', 
	login_employee, role_granted, role_revoked, role_employee;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION delete_employee_account() RETURNS TRIGGER AS $$
BEGIN
	DELETE FROM employee_account
	WHERE id_employee = NEW.id_employee;

	EXECUTE format('DROP USER %I', NEW.login);
	
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER delete_employee_fired_account
BEFORE INSERT ON employee_fired
FOR EACH ROW EXECUTE FUNCTION delete_employee_account();

CREATE OR REPLACE FUNCTION check_enter_in_employee_account(_login varchar, _password varchar)
RETURNS varchar AS $$
DECLARE
	_hash_password varchar := null;
	_id_employee uuid;
BEGIN
    IF (SELECT NOT EXISTS(
    		SELECT id_employee INTO _id_employee
    		FROM employee_account 
    		WHERE login = CONCAT('apteka_u_', _login)
    		AND password = crypt(_password, password)
		))
	THEN 
		RETURN _hash_password;
	END IF;
	
	IF (SELECT EXISTS(
    		SELECT 1 
    		FROM employee_account 
    		WHERE id_employee = _id_employee
			AND online = true
		))
	THEN
		RAISE EXCEPTION 'Вы уже авторизованы в программе на другом устройстве!';
	END IF;

	SELECT password INTO _hash_password
    FROM employee_account 
    WHERE login = CONCAT('apteka_u_', _login);

	UPDATE employee_account 
	SET online = true
    WHERE id_employee = _id_employee;
	
	RETURN _hash_password;
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE PROCEDURE log_out_employee_account()
AS $$
BEGIN
	UPDATE employee_account 
	SET online = false
    WHERE id_employee = get_current_employee();
END;
$$ LANGUAGE plpgsql;




CREATE OR REPLACE FUNCTION count_cost(_id_medicine_product uuid, _amount float) 
RETURNS float AS $$
DECLARE
	_medicine_product_cost real;
BEGIN
	SELECT cost INTO _medicine_product_cost
	FROM medicine_cost mc, medicine_product mp
	WHERE mc.id_medicine = mp.id_medicine
	AND mp.id_medicine_product = _id_medicine_product
	AND mc.packaging_form = mp.packaging_form;
	
    RETURN _amount * _medicine_product_cost;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION count_cost() 
RETURNS TRIGGER AS $$
DECLARE
	_medicine_product_cost real;
BEGIN
	SELECT cost INTO _medicine_product_cost
	FROM medicine_cost mc, medicine_product mp
	WHERE mc.id_medicine = mp.id_medicine
	AND mp.id_medicine_product = NEW.id_medicine_product
	AND mc.packaging_form = mp.packaging_form;
	
    NEW.cost := NEW.amount * _medicine_product_cost;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER count_cost_sale
BEFORE INSERT ON history_sale_medicine_product
FOR EACH ROW EXECUTE FUNCTION count_cost();



CREATE OR REPLACE FUNCTION get_medicine_product_sales(_id_medicine_product uuid) 
RETURNS TABLE (amount real, cost real, month text) AS $$
BEGIN
    RETURN QUERY(WITH medicine_product_sale AS (
				SELECT hs.amount am, hs.cost ct, (SELECT 
    				CASE extract(MONTH FROM hs.date_sale)
        				WHEN 1 THEN 'Январь'
        				WHEN 2 THEN 'Февраль'
        				WHEN 3 THEN 'Март'
        				WHEN 4 THEN 'Апрель'
        				WHEN 5 THEN 'Май'
        				WHEN 6 THEN 'Июнь'
        				WHEN 7 THEN 'Июль'
        				WHEN 8 THEN 'Август'
        				WHEN 9 THEN 'Сентябрь'
        				WHEN 10 THEN 'Октябрь'
        				WHEN 11 THEN 'Ноябрь'
        				WHEN 12 THEN 'Декабрь'
    				END) AS mth
				FROM history_sale hs
				WHERE hs.id_medicine_product = _id_medicine_product
				ORDER BY hs.date_sale
			)
			SELECT SUM(mps.am), SUM(mps.ct), mps.mth
			FROM medicine_product_sale mps
			GROUP BY mth);
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION get_medicine_product_amount_today(_id_department int) 
RETURNS TABLE ("Серийный номер" varchar,"Наименование" varchar, "Кол-во утром" real, "Продано" real, 
				"Принято" real, "Списано" real,  "Кол-во в конце дня" real) 
AS $$
BEGIN
    RETURN QUERY(SELECT mp.serial_number, mp.name, 
					(smp.amount - COALESCE(w.amount, 0) + COALESCE(hs.amount, 0) + COALESCE(mpd.amount, 0)), 
					COALESCE(hs.amount, 0), COALESCE(w.amount, 0), COALESCE(mpd.amount, 0), 
					smp.amount
				FROM medicine_product mp 
				RIGHT JOIN storage_medicine_product smp
					ON smp.id_medicine_product = mp.id_medicine_product
					AND smp.id_department = _id_department
				LEFT JOIN waybill w 
					ON w.id_medicine_product = smp.id_medicine_product AND w.date_waybill = now()::date
					AND w.id_department = _id_department
				LEFT JOIN history_sale hs 
					ON smp.id_medicine_product = hs.id_medicine_product AND hs.date_sale::date = now()::date
					AND hs.id_department = _id_department
				LEFT JOIN medicine_product_decommissioned mpd 
					ON smp.id_medicine_product = mpd.id_medicine_product AND mpd.date_decommission::date = now()::date
					AND mpd.id_department = _id_department);
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION get_medicine_product_amount_today() 
RETURNS TABLE ("Серийный номер" varchar,"Наименование" varchar, "Кол-во утром" real, "Продано" real, 
				"Принято" real, "Списано" real,  "Кол-во в конце дня" real, "Отдел" varchar) 
AS $$
BEGIN
    RETURN QUERY(SELECT mp.serial_number, mp.name, 
					(smp.amount - COALESCE(w.amount, 0) + COALESCE(hs.amount, 0) + COALESCE(mpd.amount, 0)), 
					COALESCE(hs.amount, 0), COALESCE(w.amount, 0), COALESCE(mpd.amount, 0), 
					smp.amount, d.name
				FROM medicine_product mp 
				RIGHT JOIN storage_medicine_product smp
					ON smp.id_medicine_product = mp.id_medicine_product
				LEFT JOIN waybill w 
					ON w.id_medicine_product = smp.id_medicine_product AND w.date_waybill = now()::date
					AND w.id_department = smp.id_department
				LEFT JOIN history_sale hs 
					ON smp.id_medicine_product = hs.id_medicine_product AND hs.date_sale::date = now()::date
					AND hs.id_department = w.id_department
				LEFT JOIN medicine_product_decommissioned mpd 
					ON smp.id_medicine_product = mpd.id_medicine_product AND mpd.date_decommission::date = now()::date
					AND mpd.id_department = hs.id_department
				LEFT JOIN department d ON d.id_department = smp.id_department);
END;
$$ LANGUAGE plpgsql;



CREATE EXTENSION IF NOT EXISTS pg_trgm;

CREATE OR REPLACE FUNCTION search_medicine_products_trgm(
    _search_text TEXT DEFAULT '',
    _medicine_id INT DEFAULT -1,
    _serial_number TEXT DEFAULT '',
    _form TEXT DEFAULT '',
    _min_amount REAL DEFAULT -1,
    _max_amount REAL DEFAULT -1,
    _way_enter TEXT DEFAULT '',
    _packaging_form TEXT DEFAULT '',
    _producer TEXT DEFAULT '',
    _min_date_release DATE DEFAULT NULL,
    _max_date_release DATE DEFAULT NULL,
    _min_date_expiration DATE DEFAULT NULL,
    _max_date_expiration DATE DEFAULT NULL,
    _decommissioned BOOLEAN DEFAULT NULL,
	_expired BOOLEAN DEFAULT NULL,
    _pharm_group TEXT DEFAULT '',
	_storage_condition TEXT DEFAULT '',
    _condition_release TEXT DEFAULT '',
    _component_name TEXT DEFAULT '',
    _component_measure TEXT DEFAULT '',
    _similarity_threshold REAL DEFAULT 0.3,
    _limit INT DEFAULT 100,
    _offset INT DEFAULT 0
)
RETURNS TABLE (LIKE medicine_product) AS $$
BEGIN
    RETURN QUERY
    (SELECT 
        mp.id_medicine_product,
		mp.id_medicine,
        mp.name,
        mp.serial_number,
        mp.form,
        mp.amount,
        mp.components,
        mp.way_enter,
        mp.dosage_mode,
        mp.packaging_form,
        mp.producer,
        mp.date_release,
		mp.storage_condition,
        mp.date_expiration,
        mp.analogues,
		mp.decommissioned bool
    FROM 
        medicine_product mp
    JOIN 
        medicine m ON mp.id_medicine = m.id_medicine
    WHERE 
        (_search_text = '' OR 
         mp.name %> _search_text OR
         m.MNN %> _search_text OR
         mp.serial_number %> _search_text)
    AND (_medicine_id = -1 OR mp.id_medicine = _medicine_id)
    AND (_serial_number = '' OR mp.serial_number %> _serial_number)
    AND (_form = '' OR mp.form = _form)
    AND (_min_amount = -1 OR mp.amount >= _min_amount)
    AND (_max_amount = -1 OR mp.amount <= _max_amount)
    AND (_way_enter = '' OR mp.way_enter = _way_enter)
    AND (_packaging_form = '' OR mp.packaging_form = _packaging_form)
    AND (_producer = '' OR mp.producer = _producer)
    AND (_min_date_release IS NULL OR mp.date_release >= _min_date_release)
    AND (_max_date_release IS NULL OR mp.date_release <= _max_date_release)
    AND (_min_date_expiration IS NULL OR mp.date_expiration >= _min_date_expiration)
    AND (_max_date_expiration IS NULL OR mp.date_expiration <= _max_date_expiration)
    AND (_storage_condition = '' OR mp.storage_condition %> _storage_condition)
    AND (_decommissioned IS NULL OR mp.decommissioned = _decommissioned)
    AND (_expired IS NULL 
			OR (case when _expired = true
				THEN (mp.date_expiration <= now()::date)
				ELSE (mp.date_expiration >= now()::date)
				END))
    AND (_pharm_group = '' OR m.pharm_group %> _pharm_group)
    AND (_condition_release = '' OR m.condition_release %> _condition_release)
    AND (_component_name = '' OR 
         EXISTS (
             SELECT 1 
             FROM jsonb_array_elements(mp.components) AS comp 
             WHERE (comp->>'Вещество') %> _component_name
         ))
    AND (_component_measure = '' OR 
         EXISTS (
             SELECT 1 
             FROM jsonb_array_elements(mp.components) AS comp 
             WHERE (comp->>'Мера') %> _component_measure
         ))
    AND (
        _search_text = '' AND 
        _component_name = '' OR
        GREATEST(
            CASE WHEN _search_text = '' THEN 0 ELSE 
                GREATEST(
                    word_similarity(_search_text, mp.name),
                    word_similarity(_search_text, m.MNN),
                    word_similarity(_search_text, mp.serial_number)
                )
            END,
            CASE WHEN _component_name = '' THEN 0 ELSE
                (SELECT MAX(word_similarity(_component_name, comp->>'Вещество'))
                FROM jsonb_array_elements(mp.components) AS comp)
            END
        ) >= _similarity_threshold)
    ORDER BY 
        GREATEST(
            CASE WHEN _search_text = '' THEN 0 ELSE 
                GREATEST(
                    word_similarity(_search_text, mp.name),
                    word_similarity(_search_text, m.MNN),
                    word_similarity(_search_text, mp.serial_number)
                )
            END,
            CASE WHEN _component_name = '' THEN 0 ELSE
                (SELECT MAX(word_similarity(_component_name, comp->>'Вещество'))
                FROM jsonb_array_elements(mp.components) AS comp)
            END
        ) DESC,
        mp.name, 
        mp.serial_number
    LIMIT 
        _limit
    OFFSET 
        _offset);
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION search_medicine_trgm(
    _name varchar DEFAULT '',
    _MNN varchar DEFAULT '',
    _pharm_group varchar DEFAULT '',
    _condition_release text DEFAULT '',
    _limit INT DEFAULT 100,
    _offset INT DEFAULT 0
)
RETURNS TABLE (LIKE medicine) AS $$
BEGIN
    RETURN QUERY
    (SELECT *
    FROM medicine m
    WHERE 
        (_name = '' OR m.name %> _name)
    AND (_MNN = '' OR m.MNN %> _MNN)
    AND (_pharm_group = '' OR m.pharm_group %> _pharm_group)
    AND (_condition_release = '' OR m.condition_release %> _condition_release)
    ORDER BY m.name
    LIMIT 
        _limit
    OFFSET 
        _offset);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION search_storage_medicine_product(
    _id_department int DEFAULT -1,
    _id_storage int DEFAULT -1,
    _id_place int DEFAULT -1,
    _id_medicine_product uuid DEFAULT NULL,
    _measure text DEFAULT '',
    _limit INT DEFAULT 100,
    _offset INT DEFAULT 0
)
RETURNS TABLE (LIKE storage_medicine_product) AS $$
BEGIN
    RETURN QUERY (SELECT *
		FROM storage_medicine_product smp
		WHERE (_measure = '' OR smp.measure = _measure)
		AND (_id_department = -1 OR smp.id_department = _id_department)
		AND (_id_storage = -1 OR smp.id_storage = _id_storage)
		AND (_id_place = -1 OR smp.id_place = _id_place)
		AND (_id_medicine_product is null OR smp.id_medicine_product = _id_medicine_product)
    	LIMIT 
	        _limit
    	OFFSET 
        	_offset);
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION search_sale(
    _id_department int DEFAULT -1,
    _id_storage int DEFAULT -1,
    _id_place int DEFAULT -1,
    _id_medicine_product uuid DEFAULT NULL,
    _measure text DEFAULT '',
	_date_sale_min timestamp DEFAULT NULL,
	_date_sale_max timestamp DEFAULT NULL,
	_id_employee uuid DEFAULT NULL,
    _limit INT DEFAULT 100,
    _offset INT DEFAULT 0
)
RETURNS TABLE (LIKE history_sale) AS $$
BEGIN
    RETURN QUERY (SELECT DISTINCT hs.*
		FROM history_sale hs
		JOIN history_sale_medicine_product hsmp ON hsmp.id_sale = hs.id_sale
		WHERE (_measure = '' OR hsmp.measure = _measure)
		AND (_id_department = -1 OR hs.id_department = _id_department)
		AND (_id_storage = -1 OR hsmp.id_storage = _id_storage)
		AND (_id_place = -1 OR hsmp.id_place = _id_place)
		AND (_id_medicine_product IS NULL OR hsmp.id_medicine_product = _id_medicine_product)
		AND (_date_sale_min IS NULL OR hs.date_sale >= _date_sale_min)
		AND (_date_sale_max IS NULL OR hs.date_sale <= _date_sale_max)
		AND (_id_employee IS NULL OR hs.id_employee = _id_employee)
    	LIMIT 
	        _limit
    	OFFSET 
        	_offset);
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION search_medicine_product_decommissioned_trgm(
    _id_medicine_product uuid DEFAULT NULL,
	_reason text DEFAULT '',
    _measure text DEFAULT '',
	_date_decommission_min timestamp DEFAULT NULL,
	_date_decommission_max timestamp DEFAULT NULL,
    _limit INT DEFAULT 100,
    _offset INT DEFAULT 0
)
RETURNS TABLE (LIKE medicine_product_decommissioned) AS $$
BEGIN
    RETURN QUERY (SELECT *
		FROM medicine_product_decommissioned mpd
		WHERE (_measure = '' OR mpd.measure = _measure)
		AND (_id_medicine_product IS NULL OR mpd.id_medicine_product = _id_medicine_product)
		AND (_date_decommission_min IS NULL OR mpd.date_decommission >= _date_decommission_min)
		AND (_date_decommission_max IS NULL OR mpd.date_decommission <= _date_decommission_max)
		AND (_reason = '' OR mpd.reason %> _reason)
    	LIMIT 
	        _limit
    	OFFSET 
        	_offset);
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION search_employees_trgm(
	_id_employee uuid DEFAULT NULL,
    _text_search varchar DEFAULT '',
    _address varchar DEFAULT '',
	_id_post int DEFAULT -1,
    _id_department int DEFAULT -1,
	_date_birth_min date DEFAULT NULL,
	_date_birth_max date DEFAULT NULL,
    _limit INT DEFAULT 100,
    _offset INT DEFAULT 0
)
RETURNS TABLE (LIKE employee) AS $$
BEGIN
    RETURN QUERY (SELECT *
		FROM employee e
		WHERE (_id_employee IS NULL OR e.id_employee = _id_employee)
		AND (_text_search = '' OR CONCAT(e.surname, ' ', e.name, ' ', e.patronymic) %> _text_search)
		AND (_address = '' OR e.address %> _address)
		AND (_id_post = -1 OR e.id_post = _id_post)
		AND (_id_department = -1 OR e.id_department = _id_department)
		AND (_date_birth_min IS NULL OR e.birthday >= _date_birth_min)
		AND (_date_birth_max IS NULL OR e.birthday <= _date_birth_max)
    	LIMIT 
	        _limit
    	OFFSET 
        	_offset);
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION search_waybill(
	_id_waybill int DEFAULT -1,
	_id_employee uuid DEFAULT NULL,
	_id_medicine_product uuid DEFAULT NULL,
	_id_supplier int DEFAULT -1,
    _id_department int DEFAULT -1,
	_date_waybill_min date DEFAULT NULL,
	_date_waybill_max date DEFAULT NULL,
    _limit INT DEFAULT 100,
    _offset INT DEFAULT 0
)
RETURNS TABLE (LIKE waybill) AS $$
BEGIN
    RETURN QUERY (SELECT DISTINCT w.*
		FROM waybill w
		JOIN waybill_medicine_product wmp ON wmp.id_waybill = w.id_waybill
		WHERE (_id_waybill = -1 OR w.id_waybill = _id_waybill)
		AND (_id_employee IS NULL OR w.id_employee = _id_employee)
		AND (_id_medicine_product IS NULL OR wmp.id_medicine_product = _id_medicine_product)
		AND (_id_supplier = -1 OR w.id_supplier = _id_supplier)
		AND (_id_department = -1 OR w.id_department = _id_department)
		AND (_date_waybill_min IS NULL OR w.date_waybill >= _date_waybill_min)
		AND (_date_waybill_max IS NULL OR w.date_waybill <= _date_waybill_max)
    	LIMIT 
	        _limit
    	OFFSET 
        	_offset);
END;
$$ LANGUAGE plpgsql;





--------------------------------
--------------------------------
---Создание и настройка групп---
--------------------------------
--------------------------------

CREATE GROUP apteka_g_employee;
GRANT CONNECT ON DATABASE "Apteka" TO apteka_g_employee;
GRANT USAGE ON SCHEMA public TO apteka_g_employee;
GRANT SELECT ON ALL SEQUENCES IN SCHEMA public TO apteka_g_employee;
GRANT EXECUTE ON FUNCTION 
	check_password(_password varchar), check_roles(_roles int[]),
	check_enter_in_employee_account(_login varchar, _password varchar),
	check_expired_medicine_product(), uuid_generate_v4(),
	gen_salt(text), crypt(text, text), similarity(text,text),
	search_medicine_products_trgm(
		_search_text TEXT,
    		_medicine_id INT,
    		_serial_number TEXT,
    		_form TEXT,
    		_min_amount REAL,
    		_max_amount REAL,
    		_way_enter TEXT,
    		_packaging_form TEXT,
    		_producer TEXT,
    		_min_date_release DATE,
    		_max_date_release DATE,
    		_min_date_expiration DATE,
    		_max_date_expiration DATE,
    		decommissioned BOOLEAN,
		_pharm_group TEXT,
		_condition_release TEXT,
    		_component_name TEXT,
    		_component_measure TEXT,
    		_similarity_threshold REAL,
    		_limit INT,
    		_offset INT
	)
	TO apteka_g_employee;
GRANT SELECT ON TABLE 
	employee, employee_account, employee_role, order_assign, post,
	department, storage_pharmacy, storage_place, storage_medicine_product,
	medicine, medicine_form, medicine_packaging_form, medicine_producer, 
	medicine_product, medicine_product_decommissioned, medicine_type_form, 
	medicine_way_enter, measure_measurability
	TO apteka_g_employee;

CREATE GROUP apteka_g_cashier WITH INHERIT;
GRANT apteka_g_employee TO apteka_g_cashier;
GRANT EXECUTE ON FUNCTION get_current_employee() TO apteka_g_cashier;
GRANT INSERT ON TABLE history_sale TO apteka_g_cashier;
GRANT UPDATE ON TABLE storage_medicine_product TO apteka_g_cashier;

CREATE GROUP apteka_g_department_manager WITH INHERIT;
GRANT apteka_g_employee TO apteka_g_department_manager;
GRANT EXECUTE ON FUNCTION
	get_current_employee(), get_medicine_product_amount_today(), 
	get_medicine_product_amount_today(_id_department int),
	get_medicine_product_sales(_id_medicine_product uuid)
	TO apteka_g_department_manager;
GRANT EXECUTE ON PROCEDURE 
	decomission_medicine_product(_id_medicine_product uuid, _reason character varying),
	clear_employee_data(), clear_medicine_product_sales()
	TO apteka_g_department_manager;
GRANT SELECT, UPDATE, INSERT ON TABLE
	employee, employee_account, employee_fired, order_assign, 
	storage_pharmacy, storage_place, storage_medicine_product, medicine_producer, 
	medicine_product, medicine_product_decommissioned, supplier, waybill
	TO apteka_g_department_manager;

CREATE GROUP apteka_g_director WITH INHERIT;
GRANT apteka_g_department_manager TO apteka_g_director;






--------------------------------
--------------------------------
--Заполнение тестовыми данными--
--------------------------------
--------------------------------

INSERT INTO employee (surname, name, patronymic, address, birthday, id_post, id_department)
VALUES 
('Иванов', 'Иван', 'Иванович', 'ул. Ленина, 1, кв.1', '1980-05-15', 1, 2),
('Петрова', 'Мария', 'Сергеевна', 'ул. Гагарина, 10, кв.5', '1985-08-20', 2, 2),
('Сидоров', 'Алексей', 'Петрович', 'ул. Пушкина, 15, кв.12', '1990-03-10', 3, 2),
('Кузнецова', 'Елена', 'Владимировна', 'ул. Садовая, 5, кв.3', '1992-11-25', 4, 2),
('Фёдоров', 'Дмитрий', 'Николаевич', 'ул. Мира, 20, кв.7', '1995-07-30', 5, 2);

INSERT INTO medicine_producer (producer)
VALUES 
('Bayer'), ('Pfizer'), ('Novartis'), ('Sanofi'), ('GlaxoSmithKline'),
('Teva'), ('Акрихин'), ('Фармстандарт'), ('Вертекс'), ('Биохимик'), ('Dr. Reddy''s');

INSERT INTO medicine_cost (id_medicine, packaging_form, cost)
VALUES 
(1, 'Блистер', 150.50), (1, 'Стрип', 180.75),
(1, 'Флакон', 220.40),(2, 'Туба', 580.90),
(2, 'Блистер', 320.00), (3, 'Блистер', 95.30),
(4, 'Блистер', 210.45), (5, 'Блистер', 115.20),
(5, 'Ампула', 135.60),(6, 'Блистер', 85.90), 
(7, 'Блистер', 270.60),(8, 'Блистер', 340.25), 
(9, 'Блистер', 420.80),(10, 'Флакон', 185.40), 
(10, 'Тюбик-капельница', 210.80),(11, 'Блистер', 85.50),
(11, 'Флакон', 110.25),(12, 'Блистер', 145.80),
(13, 'Блистер', 145.90),(13, 'Флакон', 195.80),
(14, 'Блистер', 380.90),(14, 'Флакон', 420.75),
(15, 'Блистер', 350.60),(15, 'Флакон', 390.40),
(16, 'Блистер', 90.20),(17, 'Блистер', 45.30),
(17, 'Тюбик-капельница', 65.80),(17, 'Флакон', 120.40),
(18, 'Блистер', 95.60),(18, 'Тюбик-капельница', 115.20),
(19, 'Блистер', 55.90),(20, 'Блистер', 75.40),
(20, 'Стрип', 85.30),(21, 'Блистер', 180.90),
(21, 'Стрип', 195.60),(22, 'Стрип', 65.80),
(22, 'Блистер', 60.40),(23, 'Стрип', 150.30),
(24, 'Стрип', 140.20),(24, 'Флакон', 160.75),
(25, 'Блистер', 180.90),(25, 'Стрип', 195.60);

INSERT INTO medicine_product (
  id_medicine, serial_number, form, amount, components, 
  way_enter, dosage_mode, packaging_form, producer, 
  date_release, storage_condition, date_expiration
)
VALUES
(1, 'NUROFEN-2023-001', 'Таблетки', 10, 
 '[{"Вещество": "Ибупрофен", "Мера": "200 мг"}]', 
 'Пероральный', 'По 1 таблетке 3 раза в день', 'Блистер', 'Bayer',
 '2023-01-15', 'Хранить при температуре не выше 25°C', '2026-01-15'),
(2, 'AMOXICLAV-2023-002', 'Таблетки', 14, 
 '[{"Вещество": "Амоксициллин", "Мера": "500 мг"}, {"Вещество": "Клавулановая кислота", "Мера": "125 мг"}]', 
 'Пероральный', 'По 1 таблетке 2 раза в день', 'Блистер', 'GlaxoSmithKline',
 '2023-02-20', 'Хранить в сухом месте при температуре до 30°C', '2026-08-20'),
(5, 'SUPRASTIN-2023-003', 'Таблетки', 20, 
 '[{"Вещество": "Хлоропирамин", "Мера": "25 мг"}]', 
 'Пероральный', 'По 1 таблетке 2-3 раза в день', 'Блистер', 'Teva',
 '2023-03-10', 'Хранить в защищенном от света месте', '2026-03-10'),
 -- Ибупрофен-Тева (аналог Нурофена)
(11, 'IBU-TEVA-2023-004', 'Таблетки', 20, 
 '[{"Вещество": "Ибупрофен", "Мера": "200 мг"}]', 
 'Пероральный', 'По 1 таблетке 3-4 раза в день', 'Блистер', 'Teva',
 '2023-04-05', 'Хранить при температуре не выше 25°C', '2026-04-05'),
-- Фаспик (аналог Нурофена)
(12, 'FASPIC-2023-005', 'Таблетки', 10, 
 '[{"Вещество": "Ибупрофен", "Мера": "400 мг"}]', 
 'Пероральный', 'По 1 таблетке 2-3 раза в день', 'Блистер', 'Акрихин',
 '2023-05-10', 'Хранить в сухом месте', '2026-05-10'),
-- Аугментин (аналог Амоксиклава)
(14, 'AUGMENTIN-2023-006', 'Таблетки', 14, 
 '[{"Вещество": "Амоксициллин", "Мера": "500 мг"}, {"Вещество": "Клавулановая кислота", "Мера": "125 мг"}]', 
 'Пероральный', 'По 1 таблетке 2 раза в день', 'Блистер', 'GlaxoSmithKline',
 '2023-06-15', 'Хранить в защищенном от влаги месте', '2026-12-15'),
-- Парацетамол
(17, 'PARACET-2023-007', 'Таблетки', 20, 
 '[{"Вещество": "Парацетамол", "Мера": "500 мг"}]', 
 'Пероральный', 'По 1-2 таблетки до 4 раз в день', 'Блистер', 'Фармстандарт',
 '2023-07-20', 'Хранить при комнатной температуре', '2026-07-20'),
-- Омез (аналог Омепразола)
(22, 'OMEZ-2023-008', 'Капсулы', 30, 
 '[{"Вещество": "Омепразол", "Мера": "20 мг"}]', 
 'Пероральный', 'По 1 капсуле 1 раз в день', 'Блистер', 'Dr. Reddy''s',
 '2023-08-25', 'Хранить в оригинальной упаковке', '2026-08-25');

INSERT INTO storage_pharmacy (name)
VALUES 
('Основной склад'), ('Холодильная камера'), ('Наркотический шкаф'), 
('Склад Б'), ('Карантинная зона');

INSERT INTO storage_place (name)
VALUES 
('Секция А1'), ('Секция А2'), ('Секция Б1'), ('Холодильник 1'), 
('Холодильник 2'), ('Шкаф 1'), ('Шкаф 2'), ('Полка 1'), ('Полка 2');

INSERT INTO storage_medicine_product (id_storage, id_place, id_medicine_product, amount, id_department)
VALUES
(1, 3, (SELECT id_medicine_product FROM medicine_product WHERE serial_number = 'IBU-TEVA-2023-004'), 40, 2),
(1, 3, (SELECT id_medicine_product FROM medicine_product WHERE serial_number = 'FASPIC-2023-005'), 25, 2),
(1, 5, (SELECT id_medicine_product FROM medicine_product WHERE serial_number = 'AUGMENTIN-2023-006'), 35, 2),
(1, 8, (SELECT id_medicine_product FROM medicine_product WHERE serial_number = 'PARACET-2023-007'), 60, 2),
(1, 9, (SELECT id_medicine_product FROM medicine_product WHERE serial_number = 'OMEZ-2023-008'), 45, 2),
(1, 1, (SELECT id_medicine_product FROM medicine_product WHERE serial_number = 'NUROFEN-2023-001'), 50, 2),
(1, 2, (SELECT id_medicine_product FROM medicine_product WHERE serial_number = 'AMOXICLAV-2023-002'), 30, 2),
(2, 4, (SELECT id_medicine_product FROM medicine_product WHERE serial_number = 'SUPRASTIN-2023-003'), 100, 2);

INSERT INTO supplier (name) 
VALUES 
('Фармакор'),
('Аптечная сеть "Здоровье"'),
('Медтехника СПб'),
('Фармация Северо-Запад'),
('Импексфарма');

-- 1. Вставляем записи о продажах
INSERT INTO history_sale (id_department, date_sale, id_employee)
SELECT 
    d.id_department,
    now() - ((random() * 364 + 1) || ' days')::interval, -- Случайная дата за последний год
    e.id_employee
FROM 
    (SELECT id_employee FROM employee WHERE surname IN ('Иванов', 'Петрова') LIMIT 2) e
CROSS JOIN
    (SELECT id_department FROM department WHERE name = 'Готовых ЛС' LIMIT 1) d;

-- 2. Вставляем проданные лекарства
INSERT INTO history_sale_medicine_product (
    id_sale, id_storage, id_place,
    id_medicine_product, amount, measure
)
SELECT 
    hs.id_sale,
    smp.id_storage,
    smp.id_place,
    mp.id_medicine_product,
    (random() * 3 + 1)::int,
    'шт.'
FROM 
    history_sale hs
CROSS JOIN LATERAL (
    SELECT mp.id_medicine_product, mp.id_medicine, mp.form
    FROM medicine_product mp
    JOIN storage_medicine_product smp ON mp.id_medicine_product = smp.id_medicine_product
    WHERE smp.amount > 0 -- Только имеющиеся на складе
    ORDER BY random()
    LIMIT (random() * 3 + 1)::int -- От 1 до 4 препаратов в чеке
) mp
JOIN storage_medicine_product smp ON mp.id_medicine_product = smp.id_medicine_product
WHERE random() < 0.8; -- 80% вероятности добавления записи

-- 1. Создаем временную последовательность для номеров накладных
CREATE TEMP SEQUENCE waybill_seq START 1000;

-- 2. Вставляем данные в основную таблицу накладных
INSERT INTO waybill (id_waybill, date_waybill, id_supplier, id_employee, id_department)
SELECT 
    nextval('waybill_seq'),
    now() - ((random() * 364 + 1) || ' days')::interval, -- Дата за последний год
    s.id_supplier,
    e.id_employee,
    d.id_department
FROM 
    supplier s
CROSS JOIN (SELECT id_employee FROM employee WHERE surname IN ('Иванов', 'Сидоров') LIMIT 2) e
CROSS JOIN (SELECT id_department FROM department WHERE name = 'Готовых ЛС') d
WHERE 
    s.name IN ('Фармакор', 'Аптечная сеть "Здоровье"')
LIMIT 10; -- Создаем 10 накладных

-- 3. Вставляем лекарственные препараты в накладные
INSERT INTO waybill_medicine_product (id_waybill, id_medicine_product, amount, measure, cost)
SELECT 
    w.id_waybill,
    mp.id_medicine_product,
    CASE 
        WHEN mp.serial_number LIKE 'NUROFEN%' THEN 50
        WHEN mp.serial_number LIKE 'AMOXICLAV%' THEN 30
        ELSE 20
    END,
    'шт.',
    CASE 
        WHEN mp.serial_number LIKE 'NUROFEN%' THEN 7500.00
        WHEN mp.serial_number LIKE 'AMOXICLAV%' THEN 12000.00
        WHEN mp.serial_number LIKE 'SUPRASTIN%' THEN 3000.00
        WHEN mp.serial_number LIKE 'PARACET%' THEN 1000.00
        WHEN mp.serial_number LIKE 'OMEZ%' THEN 6000.00
        ELSE 5000.00
    END
FROM 
    waybill w
CROSS JOIN medicine_product mp
WHERE 
    random() < 0.5 -- Каждый препарат имеет 50% шанс попасть в накладную
    AND EXISTS (
        SELECT 1 FROM supplier s 
        WHERE s.id_supplier = w.id_supplier 
        AND s.name IN ('Фармакор', 'Аптечная сеть "Здоровье"')
    AND mp.serial_number IN (
        'NUROFEN-2023-001', 'AMOXICLAV-2023-002', 'SUPRASTIN-2023-003',
        'IBU-TEVA-2023-004', 'FASPIC-2023-005', 'AUGMENTIN-2023-006',
        'PARACET-2023-007', 'OMEZ-2023-008'
    ));

-- 4. Удаляем временную последовательность
DROP SEQUENCE waybill_seq;





